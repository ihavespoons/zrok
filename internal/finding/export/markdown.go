package export

import (
	"fmt"
	"strings"
	"time"

	"github.com/ihavespoons/zrok/internal/finding"
)

// MarkdownExporter exports findings to Markdown format
type MarkdownExporter struct {
	toolName    string
	toolVersion string
	projectName string
}

// NewMarkdownExporter creates a new Markdown exporter
func NewMarkdownExporter() *MarkdownExporter {
	return &MarkdownExporter{
		toolName:    "zrok",
		toolVersion: "1.0.0",
	}
}

// SetProjectName sets the project name for the report
func (e *MarkdownExporter) SetProjectName(name string) {
	e.projectName = name
}

// Export exports findings to Markdown format
func (e *MarkdownExporter) Export(findings []finding.Finding) ([]byte, error) {
	var b strings.Builder

	// Header
	title := "Security Findings Report"
	if e.projectName != "" {
		title = fmt.Sprintf("Security Findings Report: %s", e.projectName)
	}
	b.WriteString(fmt.Sprintf("# %s\n\n", title))
	b.WriteString(fmt.Sprintf("Generated by %s v%s on %s\n\n", e.toolName, e.toolVersion, time.Now().Format("2006-01-02 15:04:05")))

	// Summary
	b.WriteString("## Summary\n\n")
	b.WriteString(fmt.Sprintf("**Total Findings:** %d\n\n", len(findings)))

	// Summary by severity
	severityCounts := make(map[string]int)
	statusCounts := make(map[string]int)
	for _, f := range findings {
		severityCounts[string(f.Severity)]++
		statusCounts[string(f.Status)]++
	}

	b.WriteString("### By Severity\n\n")
	b.WriteString("| Severity | Count |\n")
	b.WriteString("|----------|-------|\n")
	for _, sev := range finding.ValidSeverities {
		if count := severityCounts[string(sev)]; count > 0 {
			b.WriteString(fmt.Sprintf("| %s | %d |\n", e.formatSeverity(sev), count))
		}
	}
	b.WriteString("\n")

	b.WriteString("### By Status\n\n")
	b.WriteString("| Status | Count |\n")
	b.WriteString("|--------|-------|\n")
	for _, status := range finding.ValidStatuses {
		if count := statusCounts[string(status)]; count > 0 {
			b.WriteString(fmt.Sprintf("| %s | %d |\n", status, count))
		}
	}
	b.WriteString("\n")

	// Findings
	b.WriteString("## Findings\n\n")

	for _, f := range findings {
		b.WriteString(e.renderFinding(f))
		b.WriteString("\n---\n\n")
	}

	return []byte(b.String()), nil
}

func (e *MarkdownExporter) renderFinding(f finding.Finding) string {
	var b strings.Builder

	// Title with severity badge
	b.WriteString(fmt.Sprintf("### %s %s\n\n", e.formatSeverity(f.Severity), f.Title))

	// Metadata table
	b.WriteString("| Property | Value |\n")
	b.WriteString("|----------|-------|\n")
	b.WriteString(fmt.Sprintf("| **ID** | `%s` |\n", f.ID))
	b.WriteString(fmt.Sprintf("| **Severity** | %s |\n", f.Severity))
	b.WriteString(fmt.Sprintf("| **Confidence** | %s |\n", f.Confidence))
	b.WriteString(fmt.Sprintf("| **Status** | %s |\n", f.Status))
	if f.CWE != "" {
		b.WriteString(fmt.Sprintf("| **CWE** | [%s](https://cwe.mitre.org/data/definitions/%s.html) |\n", f.CWE, strings.TrimPrefix(f.CWE, "CWE-")))
	}
	if f.CVSS != nil {
		b.WriteString(fmt.Sprintf("| **CVSS Score** | %.1f |\n", f.CVSS.Score))
		b.WriteString(fmt.Sprintf("| **CVSS Vector** | `%s` |\n", f.CVSS.Vector))
	}
	b.WriteString("\n")

	// Location
	b.WriteString("#### Location\n\n")
	b.WriteString(fmt.Sprintf("**File:** `%s`", f.Location.File))
	if f.Location.LineStart > 0 {
		if f.Location.LineEnd > 0 && f.Location.LineEnd != f.Location.LineStart {
			b.WriteString(fmt.Sprintf(" (lines %d-%d)", f.Location.LineStart, f.Location.LineEnd))
		} else {
			b.WriteString(fmt.Sprintf(" (line %d)", f.Location.LineStart))
		}
	}
	b.WriteString("\n")
	if f.Location.Function != "" {
		b.WriteString(fmt.Sprintf("**Function:** `%s`\n", f.Location.Function))
	}
	b.WriteString("\n")

	// Code snippet
	if f.Location.Snippet != "" {
		b.WriteString("```\n")
		b.WriteString(f.Location.Snippet)
		if !strings.HasSuffix(f.Location.Snippet, "\n") {
			b.WriteString("\n")
		}
		b.WriteString("```\n\n")
	}

	// Description
	if f.Description != "" {
		b.WriteString("#### Description\n\n")
		b.WriteString(f.Description)
		b.WriteString("\n\n")
	}

	// Impact
	if f.Impact != "" {
		b.WriteString("#### Impact\n\n")
		b.WriteString(f.Impact)
		b.WriteString("\n\n")
	}

	// Remediation
	if f.Remediation != "" {
		b.WriteString("#### Remediation\n\n")
		b.WriteString(f.Remediation)
		b.WriteString("\n\n")
	}

	// Evidence
	if len(f.Evidence) > 0 {
		b.WriteString("#### Evidence\n\n")
		for i, ev := range f.Evidence {
			b.WriteString(fmt.Sprintf("%d. **%s:** %s\n", i+1, ev.Type, ev.Description))
			if len(ev.Trace) > 0 {
				b.WriteString("   - Trace: ")
				b.WriteString(strings.Join(ev.Trace, " â†’ "))
				b.WriteString("\n")
			}
		}
		b.WriteString("\n")
	}

	// Flow Trace
	if f.FlowTrace != nil {
		b.WriteString("#### Data Flow Trace\n\n")
		b.WriteString(fmt.Sprintf("**Source:** %s\n", f.FlowTrace.Source))
		if len(f.FlowTrace.Path) > 0 {
			b.WriteString("**Path:**\n")
			for i, step := range f.FlowTrace.Path {
				b.WriteString(fmt.Sprintf("%d. %s\n", i+1, step))
			}
		}
		if len(f.FlowTrace.Guards) > 0 {
			b.WriteString("**Guards:**\n")
			for _, guard := range f.FlowTrace.Guards {
				b.WriteString(fmt.Sprintf("- %s\n", guard))
			}
		}
		b.WriteString(fmt.Sprintf("**Sink:** %s\n", f.FlowTrace.Sink))
		if f.FlowTrace.Unguarded {
			b.WriteString("**Verdict:** UNGUARDED\n")
		} else {
			b.WriteString("**Verdict:** GUARDED\n")
		}
		b.WriteString("\n")
	}

	// References
	if len(f.References) > 0 {
		b.WriteString("#### References\n\n")
		for _, ref := range f.References {
			b.WriteString(fmt.Sprintf("- %s\n", ref))
		}
		b.WriteString("\n")
	}

	// Tags
	if len(f.Tags) > 0 {
		b.WriteString("**Tags:** ")
		tags := make([]string, len(f.Tags))
		for i, tag := range f.Tags {
			tags[i] = fmt.Sprintf("`%s`", tag)
		}
		b.WriteString(strings.Join(tags, ", "))
		b.WriteString("\n\n")
	}

	return b.String()
}

func (e *MarkdownExporter) formatSeverity(s finding.Severity) string {
	switch s {
	case finding.SeverityCritical:
		return "ðŸ”´ **CRITICAL**"
	case finding.SeverityHigh:
		return "ðŸŸ  **HIGH**"
	case finding.SeverityMedium:
		return "ðŸŸ¡ **MEDIUM**"
	case finding.SeverityLow:
		return "ðŸŸ¢ **LOW**"
	case finding.SeverityInfo:
		return "ðŸ”µ **INFO**"
	default:
		return string(s)
	}
}

// ContentType returns the MIME type for Markdown
func (e *MarkdownExporter) ContentType() string {
	return "text/markdown"
}

// FileExtension returns the file extension for Markdown
func (e *MarkdownExporter) FileExtension() string {
	return ".md"
}

// FormatName returns the format name
func (e *MarkdownExporter) FormatName() string {
	return "markdown"
}
